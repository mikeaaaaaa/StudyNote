# 正则表达式

动机:![1666420354298](C:\Users\豪哥\Desktop\assets\1666420354298.png)

## 字符

==正则表达式是由普通字符与元字符组合的表达式==

### 普通字符：

![1666420489949](C:\Users\豪哥\Desktop\assets\1666420489949.png)

在python中可以匹配中文字符

### 或关系

![1666420595385](C:\Users\豪哥\Desktop\assets\1666420595385.png)

表示 ==匹配‘|’两侧那个正则表达式都可以！！！

### 匹配单个字符

![1666420712041](C:\Users\豪哥\Desktop\assets\1666420712041.png)

注意：！！！在这里一个英文或者中文字符都算一个字符！！！！

 		==\n不能使用.来匹配==

### 匹配字符集

![1666420781933](C:\Users\豪哥\Desktop\assets\1666420781933.png)

！！！一个字符集只能表示一个字符（或者说分组	）！！！

### 匹配字符集反集

![1666420864237](C:\Users\豪哥\Desktop\assets\1666420864237.png)

### 匹配字符串开始位置

![1666421003428](C:\Users\豪哥\Desktop\assets\1666421003428.png)

（必须是目标字符串的开头）

### 匹配字符串的结尾位置

![1666421079170](C:\Users\豪哥\Desktop\assets\1666421079170.png)

==**^、$必然在正则表达式的开头结尾，**==

==^、$同时出现======》称为完全匹配==！！！！

### 匹配重复字符

#### 元字符 *

![1666421239536](C:\Users\豪哥\Desktop\assets\1666421239536.png)

==0或多次==，和前面的那个部分是一个整体，代表前面的部分重复出现

##### 练习：找出每个单词

```python
re.findall('[a-zA-Z0-9‘“]*','How are you?')
```

![1666421483007](C:\Users\豪哥\Desktop\assets\1666421483007.png)

结果出现很多的 空 是因为findall的原因！！！！，因为*可以表示0个，所以当匹配匹配不到的字符的收，会返回一个空！！

##### 大写字母开头的单词

```python
re.findall('[A-Z][a-zA-Z]*','Are Yuu Xaa')
```



#### 元字符+

![1666421740312](C:\Users\豪哥\Desktop\assets\1666421740312.png)

#### 元字符？

![1666421796842](C:\Users\豪哥\Desktop\assets\1666421796842.png)

##### 匹配出数字

```python
re.findall('-?[0-9]+','120 -20 30')
```

##### 模拟split（’ ‘）

`re.findall('[^ ]+','i you i ii')`

#### 元字符{n}

![1666422254907](C:\Users\豪哥\Desktop\assets\1666422254907.png)

#### 元字符{n,m}

![1666422303491](C:\Users\豪哥\Desktop\assets\1666422303491.png)

包含m和n

### 匹配（非）数字字符

![1666422411332](C:\Users\豪哥\Desktop\assets\1666422411332.png)

等同于：`[0-9][^0-9]`，第二个就是除了数字都能匹配

### 匹配（非）普通字符

![1666422533068](C:\Users\豪哥\Desktop\assets\1666422533068.png)

==数字、字母、下划线、汉字==，换句话说，==所有语言的字加上唯一符号下划线==

### 匹配任意（非）空字符

![1666422635798](C:\Users\豪哥\Desktop\assets\1666422635798.png)

常见的空字符 ==\n\r空格==

##### 模拟split（’ ‘）

`re,findall('\S','how are you AAA')`

### 匹配（非）单词的边界位置

![1666422866825](C:\Users\豪哥\Desktop\assets\1666422866825.png)

#### 只想匹配单词 is

`re.findall(r'\bis\b',This is all asi ais is)` 

#### 单词末尾为is

`re.findall(r'\Bis\b',This is all asi ais is)` 

### 元字符总结

![1666423124367](C:\Users\豪哥\Desktop\assets\1666423124367.png)

## 正则表达式的转义

所谓转义 ----我们之前学过：就是在某个字符前加上\表示特殊含义

![1666423240616](C:\Users\豪哥\Desktop\assets\1666423240616.png)

==加一个斜杠让一些特殊字符失去特殊含义==

### 匹配所有数字（含小数）

`re.findall('-?\d\.?\d+','aaa 12 12.3 -29.0 20')`

## 原生字符串

![1666424517754](C:\Users\豪哥\Desktop\assets\1666424517754.png)

实际上，我们写的正则表达式其实也是字符串，只是python库会帮我们 将这些字符串转为 正则表达式，因此，对于上图的两种写法，上面那种是更加正确的，下面那个也没错是因为：在转为正则的过程种，python解释器遇到斜杠时，会自动进行转义，但是由于python解释器能识别的转移也就那几种，对于\$他想转义但是没有对应的，所以就放弃了转义。。。。。。换句话说，只有在python解释器中能转义的我们必须在前面加双斜杠，否则会出错。。。，例如\b的使用。。。

例如：我想匹配两个连虚的斜杠\\\,按理正则表达式应该是\\\\就行了，但是由于python解释器的自动转义，我们得在前面写成\\\\\\\四条斜杠

`re.findall('\\\\','\\')`

![1666425029318](C:\Users\豪哥\Desktop\assets\1666425029318.png)

但是这种太麻烦了。。。。

所以就引出了------->原生字符串

==作用:不会经过python字符串的解析==

![1666425101638](C:\Users\豪哥\Desktop\assets\1666425101638.png)

![1666425121677](C:\Users\豪哥\Desktop\assets\1666425121677.png)

==换句话来说：不会经过字符串原生的转义==，省的我们两层转移的麻烦！！！

这样，对于正则表达式，我们该写什么就写什么了

## 贪婪模式与非贪婪模式

！！！默认都是贪婪模式！！！

![1666425273487](C:\Users\豪哥\Desktop\assets\1666425273487.png)

加一个问号：这真的是我所需要的嘛？这样你就变得不那么贪婪

==在原来的可选择原生字符前加一个问好，就有了非贪婪模式==

![1666425350731](C:\Users\豪哥\Desktop\assets\1666425350731.png)

#### 连同中括号以及里面的内容全都摘出来

`re.findall(r'\[.+?\]')`

![1666425632340](C:\Users\豪哥\Desktop\assets\1666425632340.png)

#### 练习

![1666425848938](C:\Users\豪哥\Desktop\assets\1666425848938.png)

## 分组

![1666425908730](C:\Users\豪哥\Desktop\assets\1666425908730.png)

由于findall无法很好的展示分组效果，我么使用search函数

==分组仅仅是改变一些元字符的作用对象==

![1666426018130](C:\Users\豪哥\Desktop\assets\1666426018130.png)

==可以找到对应分组的一部分==

![1666426163982](C:\Users\豪哥\Desktop\assets\1666426163982.png)

![1666426210974](C:\Users\豪哥\Desktop\assets\1666426210974.png)

==重点==

### 分组规则

![1666426276118](C:\Users\豪哥\Desktop\assets\1666426276118.png)

![1666426296531](C:\Users\豪哥\Desktop\assets\1666426296531.png)

==从1开始给子组排序==，0代表匹配到的整个字符串

## python re模块

### compile

![1666426481157](C:\Users\豪哥\Desktop\assets\1666426481157.png)

通过正则表达式，也可以调用方法

### findall

![1666426613015](C:\Users\豪哥\Desktop\assets\1666426613015.png)

==如果正则表达式中有子组，则只会获取到子组中的匹配内容==

==每一处的子组都会封装成一个元组，放入list中==

![1666426724298](C:\Users\豪哥\Desktop\assets\1666426724298.png)

### split

![1666426818611](C:\Users\豪哥\Desktop\assets\1666426818611.png)

==按照正则表达式内容切割字符串==

==剩下的内容返回为list==

### sub

![1666426907269](C:\Users\豪哥\Desktop\assets\1666426907269.png)

### match对象

可以提供更加丰富的匹配信息，==一个match对象对应一处匹配内容==

#### match对象的产生

#### ![1666427110817](C:\Users\豪哥\Desktop\assets\1666427110817.png)

上图中圈出的两块函数可以提供返回match对象

##### finditer方法

![1666427225264](C:\Users\豪哥\Desktop\assets\1666427225264.png)

##### match方法

![1666427362625](C:\Users\豪哥\Desktop\assets\1666427362625.png)

相当于直接在正则表达式前 加了一个==^==

##### search函数

![1666427414176](C:\Users\豪哥\Desktop\assets\1666427414176.png)

![1666427438739](C:\Users\豪哥\Desktop\assets\1666427438739.png)

#### match对象的属性方法

##### 属性变量：

![1666428164467](C:\Users\豪哥\Desktop\assets\1666428164467.png)

开始位置与结尾位置都是从0开始算的

![1666428320183](C:\Users\豪哥\Desktop\assets\1666428320183.png)

##### 属性方法：

![1666428415993](C:\Users\豪哥\Desktop\assets\1666428415993.png)

![1666428429880](C:\Users\豪哥\Desktop\assets\1666428429880.png)

group是我们用的最多的。。。

